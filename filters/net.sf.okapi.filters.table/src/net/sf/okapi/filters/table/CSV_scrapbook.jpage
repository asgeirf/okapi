/*===========================================================================
  Copyright (C) 2008-2009 by the Okapi Framework contributors
-----------------------------------------------------------------------------
  This library is free software; you can redistribute it and/or modify it 
  under the terms of the GNU Lesser General Public License as published by 
  the Free Software Foundation; either version 2.1 of the License, or (at 
  your option) any later version.

  This library is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of 
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser 
  General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License 
  along with this library; if not, write to the Free Software Foundation, 
  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

  See also the full LGPL text here: http://www.gnu.org/copyleft/lesser.html
===========================================================================*/

package net.sf.okapi.filters.table;

import net.sf.okapi.filters.plaintext.common.CompoundFilterParameters;

/**
 * Table Filter parameters
 * 
 * @version 0.1, 09.06.2009
 * @author Sergei Vasilyev  
 */

public class Parameters extends CompoundFilterParameters {
	
	/**
	 * @see tableType
	 */
	public static int TABLE_AUTODETECT = 0;
	public static int TABLE_FIXED_COLUMN_WIDTH = 1;
	public static int TABLE_DELIMITED = 2;	
		
	/**
	 * @see detectColumnsMode
	 */
	public static int DETECT_COLUMNS_NONE = 0;
	public static int DETECT_COLUMNS_FIELD_NAMES = 1;
	public static int DETECT_COLUMNS_FIXED_NUMBER = 2;
	
	/**
	 * @see sendHeaderMode
	 */
	public static int SEND_HEADER_NONE = 0;
	public static int SEND_HEADER_FIELD_NAMES_ONLY = 1;
	public static int SEND_HEADER_ALL = 2;
	
	/**
	 * @see trimMode
	 */
	public static int TRIM_NONE = 0;
	public static int TRIM_NONQUALIFIED_ONLY = 1;
	public static int TRIM_ALL = 2;
		
	/**
	 * 
	 */
	public int tableType = TABLE_DELIMITED;
	
	/**
	 * Index of the row (1-based) containing filed names (column captions).<p>
	 * Default: 1
	 */
	public int fieldNamesRow = 1;
	
	/**
	 * Index of the row (1-based) where actual data start after the header.<p>
	 * Default: 2
	 */
	public int valuesStartRow = 2;
	
	/**
	 * The filter can detect number of columns in the input. This option specifies the way of columns number detection:
	 * <li>DETECT_COLUMNS_NONE = 0 - no detection is performed, if different rows contain different number of values, then different 
	 * number of TUs will be sent for different rows  
	 * <li>DETECT_COLUMNS_FIELD_NAMES = 1 - number of columns is determined by the number of field names listed in the row 
	 * specified by the fieldNamesRow parameter. 
	 * <li>DETECT_COLUMNS_FIXED_NUMBER = 2 - number of columns is explicitly specified by the numColumns parameter.<p>
	 * Default: DETECT_COLUMNS_NONE
	 */
	public int detectColumnsMode = DETECT_COLUMNS_NONE;
	
	/**
	 * Number of columns in the input. This option is active only if detectColumnsMode = DETECT_COLUMNS_FIXED_NUMBER.<p>
	 * Extra columns are dropped, empty TUs are created for missing columns.<p>
	 */
	public int numColumns = 1;
	
	/**
	 * If there are one or more lines containing description of the data, names of fields etc., 
	 * and actual data don't start in the first line, then such first lines are considered a header, and this option specifies how to handle them:
	 * <li>SEND_HEADER_NONE = 0 - none of the header lines are sent as text units
	 * <li>SEND_HEADER_FIELD_NAMES_ONLY = 1 - only the values in the line specified by fieldNamesLineNum are sent as text units
	 * <li>SEND_HEADER_ALL = 2 - values in all header lines are sent as text units
	 * @see valuesStartLineNum
	 * @see fieldNamesLineNum
	 */
	public int sendHeaderMode = SEND_HEADER_FIELD_NAMES_ONLY;
	
	/**
	 * Specifies how field values are trimmed of spaces:
	 * <li>TRIM_NONE = 0 - field values are not trimmed
	 * <li>TRIM_NONQUALIFIED_ONLY = 1 - only non-qualified field values are trimmed, leading and trailing spaces remain in qualified fields
	 * <li>TRIM_ALL = 2 - both non-qualified and qualified field values are trimmed of leading and trailing spaces.
	 * Default: TRIM_NONQUALIFIED_ONLY
	 * @see textQualifier
	 */
	public int trimMode = TRIM_NONQUALIFIED_ONLY;
	
	/**
	 * Symbol or a string separating fields in a row. <p>
	 * Default: , (comma)
	 */
	public String fieldDelimiter = ",";
	
	/** 
	 * Symbol or a string before and after field value to allow special characters inside the field. 
	 * For instance, this field will not be broken into parts: "Field, containing comma, \", "" and \n".
	 * The qualifiers are not included in translation units.<p>  
	 * Default: " (quotation mark)
	 */ 
	public String textQualifier = "\"";
	
	/** 
	 * Indicates which columns contain ID. Can be represented by one of the following string types:
	 *<li>"1" - index (1-based) of the column, containing ID
	 *<li>"ID" - name of the column, containing ID
	 *<li>"1,2,5" - comma-delimited list (1-based) of indexes of the columns, containing ID
	 *<li>"ID,ParentID" - comma-delimited list of names of the columns, containing ID.<p>
	 */
	public String idColumns = "";			
	
	/** 
	 * Indicates which columns contain source text. Can be represented by one of the following string types:
	 *<li>"1" - index (1-based) of the column, containing source text
	 *<li>"1,2,5" - comma-delimited list (1-based) of indexes of the columns, containing source text
	 */
	public String sourceColumns = "";		
	
	/** 
	 * Indicates which columns contain target text. Can be represented by one of the following string types:
	 *<li>"1" - index (1-based) of the column, containing target text
	 *<li>"1,2,5" - comma-delimited list (1-based) of indexes of the columns, containing target text
	 */
	public String targetColumns = "";		
	
	/** 
	 * Indicates which columns contain comments. Can be represented by one of the following string types:
	 *<li>"1" - index (1-based) of the column, containing a comment
	 *<li>"1,2,5" - comma-delimited list (1-based) of indexes of the columns, containing comments
	 */
	public String commentColumns = "";
	
	/** 
	 * Specifies positions of fixed-width table columns. The positions are x-coordinates, like the position of a char in its string.
	 * The difference is that columnStartPositions are 1-based.  
	 * Can be represented by one of the following string types:
	 *<li>"1" - position (1-based) where the column starts
	 *<li>"1,2,5" - comma-delimited list (1-based) of starting positions of the table columns
	 */
	public String columnStartPositions = "";
		
//----------------------------------------------------------------------------------------------------------------------------	
	
	public Parameters() {
		
		super();		
		
		reset();
		toString(); // fill the list
	}

	public void reset() {
		
		super.reset();
		
		// All parameters are set to defaults here
		tableType = TABLE_DELIMITED;
		fieldNamesRow = 1;
		valuesStartRow = 2;
		detectColumnsMode = DETECT_COLUMNS_NONE;
		numColumns = 1;
		sendHeaderMode = SEND_HEADER_FIELD_NAMES_ONLY;
		trimMode = TRIM_NONQUALIFIED_ONLY;
		fieldDelimiter = ",";
		textQualifier = "\"";
		idColumns = "";
		sourceColumns = "";
		targetColumns = "";
		commentColumns = "";
		columnStartPositions = "";
	}

	public void fromString(String data) {
		
		reset();
		
		super.fromString(data);
		
		buffer.fromString(data);
		
		// All parameters are retrieved here		
		tableType = buffer.getInteger("tableType", 1);
		fieldNamesRow = buffer.getInteger("fieldNamesLineNum", 1);
		valuesStartRow = buffer.getInteger("valuesStartLineNum", 2);
		detectColumnsMode = buffer.getInteger("detectColumnsMode", DETECT_COLUMNS_NONE);
		numColumns = buffer.getInteger("numColumns", 1);
		sendHeaderMode = buffer.getInteger("sendHeaderMode", SEND_HEADER_FIELD_NAMES_ONLY);
		trimMode = buffer.getInteger("trimMode", TRIM_NONQUALIFIED_ONLY);		
		fieldDelimiter = buffer.getString("fieldDelimiter", ",");
		textQualifier = buffer.getString("textQualifier", "\"");
		idColumns = buffer.getString("idColumns", "");
		sourceColumns = buffer.getString("sourceColumns", "");
		targetColumns = buffer.getString("targetColumns", "");
		commentColumns = buffer.getString("commentColumns", "");
		columnStartPositions = buffer.getString("columnStartPositions", "");
	}
	
	@Override
	public String toString () {
		
		buffer.reset();
		
		super.toString(); // Will write to the same buffer
		
		// All parameters are set here				
		buffer.setInteger("tableType", tableType);
		buffer.setInteger("fieldNamesLineNum", fieldNamesRow);
		buffer.setInteger("valuesStartLineNum", valuesStartRow);
		buffer.setInteger("detectColumnsMode", detectColumnsMode);
		buffer.setInteger("numColumns", numColumns);
		buffer.setInteger("sendHeaderMode", sendHeaderMode);
		buffer.setInteger("trimMode", trimMode);		
		buffer.setString("fieldDelimiter", fieldDelimiter);
		buffer.setString("textQualifier", textQualifier);
		buffer.setString("idColumns", idColumns);
		buffer.setString("sourceColumns", sourceColumns);
		buffer.setString("targetColumns", targetColumns);
		buffer.setString("commentColumns", commentColumns);
		buffer.setString("columnStartPositions", columnStartPositions);
		
		return buffer.toString();
	}
	
}



public List<String> getColumnNames() {
		
		if (columnNames == null)
			columnNames = new ArrayList<String>();
		
		// If we got no column names, but could, just try it
//		if ((columnNames.size() == 0) && (params != null) && (params.columnNamesLineNum != 0)) { 
			
			try {
				BaseTableFilter columnNamesReader = this.getClass().newInstance();
				//System.out.println(columnNamesReader.getClass().getName());
				
				Parameters params = (Parameters) columnNamesReader.getParameters();
				params.sendHeaderMode = Parameters.SEND_HEADER_COLUMN_NAMES_ONLY;
				int numLinesToRead = this.params.columnNamesLineNum;
				
			} catch (Exception e) {
			}
//		}
		
		return columnNames;
	}


Parameters p3;
	
	protected boolean checkParameters(Class<?> ref) {
	       return ref.isInstance(this.p3);
	}
	
	@Test
	public void testParameters() {
		
		net.sf.okapi.filters.plaintext.Parameters p1;
		net.sf.okapi.filters.csv.Parameters p2;
		
		assertTrue(checkParameters(Parameters));
//--------------------------------

Parameters params;
	@SuppressWarnings("unchecked")
	boolean checkClass(Class c) {
		
		return (params.getClass().isInstance(c));  
	}
	
	net.sf.okapi.filters.plaintext.Parameters pp;
	
	boolean b = checkClass(params);
	
/*===========================================================================
  Copyright (C) 2008-2009 by the Okapi Framework contributors
-----------------------------------------------------------------------------
  This library is free software; you can redistribute it and/or modify it 
  under the terms of the GNU Lesser General Public License as published by 
  the Free Software Foundation; either version 2.1 of the License, or (at 
  your option) any later version.

  This library is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of 
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser 
  General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License 
  along with this library; if not, write to the Free Software Foundation, 
  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

  See also the full LGPL text here: http://www.gnu.org/copyleft/lesser.html
===========================================================================*/

package net.sf.okapi.filters.csv;

import net.sf.okapi.common.EventType;
import net.sf.okapi.common.IParameters;
import net.sf.okapi.common.MimeTypeMapper;
import net.sf.okapi.common.Util;
import net.sf.okapi.common.resource.Ending;
import net.sf.okapi.common.resource.StartGroup;
import net.sf.okapi.common.resource.TextContainer;
import net.sf.okapi.filters.plaintext.PlainTextFilter;
import net.sf.okapi.filters.plaintext.TextProcessingResult;

public class Old_CSV_Filter extends PlainTextFilter {
		
	private Parameters params = null;
	private boolean chunkMerging = false;
	private String cumulativeChunk = "";
	private int startGroupIndex = -1;
		
	public Old_CSV_Filter() {
		
		setName("okf_csv");
		setMimeType(MimeTypeMapper.CSV_MIME_TYPE);		
		setParameters(new Parameters());	// CSV Filter's parameters
		
		addConfiguration(true, 
				"",
				"CSV File",
				"Comma-separated values, optional header fith field names", 
				null);
		addConfiguration(false,
				"-table",
				"CSV Table",
				"Tab-separated columns with optional column captions", 
				null);
		addConfiguration(false,
				"-fwc",
				"Fixed-Width Columns",
				"Fixed-width columns padded with white-spaces", 
				null);
	}

	protected void init(IParameters params) {
		
		if (params instanceof Parameters)
			this.params = (Parameters) params;
		else
			throwParametersException(this.params, params);
					
		cumulativeChunk = "";
		chunkMerging = false;
	}
		
	protected TextProcessingResult processChunk(String chunk) {
		
		if (!Util.isEmpty(chunk)) {
			String trimmedChunk = chunk.trim();
			int len = Util.getLength(params.textQualifier);
			
			if (trimmedChunk.startsWith(params.textQualifier) && trimmedChunk.endsWith(params.textQualifier)) {				
				chunk = trimmedChunk.substring(len, Util.getLength(trimmedChunk) - len);
				return defaultProcessText(chunk);
			}
			
			if (trimmedChunk.startsWith(params.textQualifier) && !trimmedChunk.endsWith(params.textQualifier)) {
				return TextProcessingResult.DELAYED_DECISION;
			}
		}
		
		return super.defaultProcessText(chunk);
	}

	private String[] splitLine(String line) {
		
		if (Util.isEmpty(params.fieldDelimiter)) return new String[] {line};  // The whole line is considered a chunk
		
		// Block delimiters inside quoted fields
			if (!Util.isEmpty(params.textQualifier)) {
				
			}
		// Block quotations inside quotations
		
			
		// Split line into fields									
		String[] res = line.split(params.fieldDelimiter);
		
		// If numColumns <> -1, analyze chunks, add empty missing or delete extra ones
		
		return res;
	}
	
	@Override
	protected TextProcessingResult processLine(TextContainer lineContainer) {
				
		if (Util.isEmpty(lineContainer)) return TextProcessingResult.REJECTED;
		
		String line = lineContainer.getCodedText();
		
		String[] chunks = splitLine(line);
		if (chunks == null) return super.processLine(lineContainer); // No chunks, process the whole line
		
		boolean tuSent = false;
		startGroupIndex = getQueueSize();
		String chunkToProcess = "";
		
		// Process chunks
		for (int i = 0; i < chunks.length; i++) {
			String chunk = chunks[i];
									
			if (chunkMerging) {
				cumulativeChunk += params.fieldDelimiter + chunk;
				chunkToProcess = cumulativeChunk;
			}
			else
				chunkToProcess = chunk;
			
			switch (processChunk(chunkToProcess)) { 			
			
			case REJECTED:				
				if (getActiveSkeleton() != null) {
					
				// Add the whole line to skeleton
					if (chunkMerging) 
						getActiveSkeleton().append(cumulativeChunk);
					else
						getActiveSkeleton().append(chunk);
					
				// Add field delimiter to skeleton
					if (i < chunks.length - 1) // If not the last field in the line
						getActiveSkeleton().append(params.fieldDelimiter);
				}
				chunkMerging = false;
				continue;
				
			case ACCEPTED:						
				// Add field delimiter to skeleton
				if (i < chunks.length - 1) // If not the last field in the line
					if (getActiveSkeleton() != null) getActiveSkeleton().append(params.fieldDelimiter);
		
				tuSent = true;
				chunkMerging = false;
				break;
				
			case COMBINE_WITH_NEXT:
				if (!chunkMerging) {
					chunkMerging = true;
					cumulativeChunk = chunkToProcess;
				}
				
				continue;
		}
						
		} // for-loop
		
		if (chunkMerging) {
			return TextProcessingResult.COMBINE_WITH_NEXT;
		}
		else {
			// Wrap the record with Start group/End group
			if (tuSent) {
				sendEvent(startGroupIndex, EventType.START_GROUP, new StartGroup(""));
				sendEvent(EventType.END_GROUP, new Ending(""));
			}
			
			return (tuSent) ? TextProcessingResult.ACCEPTED : TextProcessingResult.REJECTED;
		}
					
	}

}




