<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Okapi Framework Developer's Guide - Getting Started</title>
<link rel="stylesheet" type="text/css" href="../okapi.css">
</head>

<body>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
	<tr class="head">
		<td class="head" colspan="2"><h1 class="head">Okapi Framework - Developer's Guide</h1>
		<h2 class="head2">Getting Started</h2></td>
	</tr>
	<tr>
		<td class="smalltoc"><p>
			- <a href="#Overview">Overview</a><br/>
			- <a href="#ReadingDocument">Reading a Document</a><br/>
			- <a href="#ModifyingDocument">Modifying a Document</a><br/>
			- <a href="#TextUnits">Working with Text Units</a></p></td>
		<td class="hmenu">
			<div class="hmenu"><table align="right"><tr>
				<td><a href="glossary.html">Glossary</a></td>
				<td><a href="index.html">Guide Content</a></td>
				<td><a href="http://okapi.opentag.com">Okapi Framework</a></td>
			</tr></table></div>
		</td>
	</tr>
</table>

<h2><a name="overview"></a>Overview</h2>
<p>Applications like Rainbow are built on top of the framework, but it is quite 
easy to develop other tools and scripts that use directly the framework components. 
With these components you can do things like:</p>
<ul>
	<li>Read documents in different formats into a set of standardized resources.</li>
	<li>Store the extracted text into a common representation, where text is 
	separated from inline codes.</li>
	<li>Manipulate the extracted text and any modifiable 
	properties associated to it.</li>
	<li>Re-write the document in its original format, but with its extractable 
	parts modified if needed.</li>
	<li>Segment extracted text into sentences.</li>
	<li>Chain sequences of independent steps that perform different actions on 
	the resources generated by the filters.</li>
	<li>and much more...</li>
</ul>
<p>This section describes how to write simple programs that use the Okapi 
Framework components to perform simple tasks such as reading and modifying a 
document.</p>
<h2><a name="readingDocument"></a>Reading a Document</h2>
<p>One of the most important actors in the framework is the 
<a href="glossary.html#filter">filter</a>. All 
filters are accessible through a single common API: the <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code> 
interface. They take an input document in a given format and generate 
<a href="glossary.html#event">events</a> 
that give you access to the extractable text of the document, as well as the 
properties associated to it.</p>
<p>The filters are designed to work through a 
<a href="glossary.html#pipeline">pipeline</a>. A pipeline is a 
set of sequential steps, each step receiving events, processing it (if needed) and 
sending it to the next step. The framework has pre-defined components to build and execute 
pipelines easily, but we will see that later.</p>
<p>For now, let's concentrate on the filter itself. You do not need to use a pipeline to work with filters, as long as you know 
what event to send and receive.</p>
<p>Most events have associated <a href="glossary.html#resource">resources</a>. Each resource is different depending 
on the type of event. Extracted text, properties, as well as grouping 
information are carried in those resources. The following table show all the 
kinds of event that can go through a pipeline.</p>
<p><a name="eventsAndResources"></a>Events and Corresponding Resources:</p>
<table border="1" id="table1" cellspacing="0" cellpadding="4">
	<tr>
		<th>Events</th>
		<th>Resource</th>
		<th>Filter-Specific Event?</th>
	</tr>
	<tr>
		<td><code>FILE_RESOURCE</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/FileResource.html">FileResource</a></code></td>
		<td>no (corresponds to a file by itself).</td>
	</tr>
	<tr>
		<td><code>START_DOCUMENT</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/StartDocument.html">StartDocument</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>START_SUBDOCUMENT</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/StartSubDocument.html">StartSubDocument</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>START_GROUP</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/StartGroup.html">StartGroup</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>DOCUMENT_PART</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/DocumentPart.html">
		DocumentPart</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>TEXT_UNIT</code></td>
		<td><code>
		<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html">TextUnit</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>END_GROUP</code></td>
		<td><code><a href="../javadoc/net/sf/okapi/common/resource/Ending.html">Ending</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>END_SUBDOCUMENT</code></td>
		<td><code><a href="../javadoc/net/sf/okapi/common/resource/Ending.html">Ending</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>END_DOCUMENT</code></td>
		<td><code><a href="../javadoc/net/sf/okapi/common/resource/Ending.html">Ending</a></code></td>
		<td>yes</td>
	</tr>
	<tr>
		<td><code>CANCELED</code></td>
		<td>none</td>
		<td>no (used when a process is canceled)</td>
	</tr>
	<tr>
		<td><code>FINISHED</code></td>
		<td>none</td>
		<td>no (used by the multi-threaded pipeline)</td>
	</tr>
	</table>
<p>A filter always generates at least the <code>START_DOCUMENT</code> 
and <code>END_DOCUMENT</code> events. All other filter-specific events may or may not be generated depending on each filter and each 
document. See the section <a href="filters.html#filterEvents">Filter Events</a> 
for more details.</p>
<p>Any event that is not understood by a component should be simply passed along 
down the pipeline.</p>
<h3><a name="creatingFilter"></a>Creating the Filter</h3>
<p>To use a filter, you have first to create a filter object. The Okapi 
Framework provides you with several filters, and you can write your own as well. 
In the example below, we use the <code>
net.sf.okapi.filters.properties.PropertiesFilter</code> class which implement 
the <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code> 
interface for Java Properties files.</p>
<pre>// Create a filter object
IFilter filter = new PropertiesFilter();</pre>
<h3><a name="configuringFilter"></a>Configuring the Filter</h3>
<p>The next step is to configure the filter. There are options you always need to set:</p>
<ul>
	<li>The language of the text to extract.</li>
	<li>The default encoding of the document to process.</li>
	<li>Whether or not you want the filter to generate the 
	<a href="glossary.html#skeleton">skeleton</a> for 
	the document (we'll see more about the skeleton later).</li>
</ul>
<p>In the code below we set the source language to English, using the same standard 
language tag identifiers you would use with HTML and XML (BCP-47). We set the default encoding to UTF-16 because 
our input will be a Unicode string. Note that some filters will be able to detect 
automatically the correct encoding of the input and ignore this value. And 
lastly, we ask the filter to generate the skeleton. It will be useful later.</p>
<pre>// Set the filter general options
filter.setOptions(&quot;en&quot;, &quot;UTF-16&quot;, true);</pre>
<p>Some filters have also a second set of options that are specific to them. The <code>PropertiesFilter</code> has such options, but the defaults are 
just fine for the example so we won't use any additional parameters. If you have to set these 
filter-specific parameters, the method <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#setParameters(net.sf.okapi.common.IParameters)">
IFilter.setParameters()</a></code> would be the one to call at this point. The 
method <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#getParameters()">
IFilter.getParameters()</a></code> allows you to retrieve the current 
parameters.</p>
<p class="question"><b>Question</b>: Is there an easy way to edit the 
filter-specific parameters?</p>
<p class="answer">It depends. The parameters are accessible through the <code>
<a href="../javadoc/net/sf/okapi/common/IParameters.html">IParameters</a></code> 
interface and, at the least, this interface allows to save the parameters to a 
file, that file can be a simple property-like text file. Some filters also 
provide UI for modifying their parameters. See the
<a href="filters.html#filterParameters">Filter Parameters</a> section of the 
guide for more details.</p>
<h3><a name="openInputDoc"></a>Opening the Input Document</h3>
<p>Once all the options are set, the next step is to open the input document. 
There are different methods to do this:</p>
<ul>
	<li>Provide an <code>InputStream</code> object.</li>
	<li>Provide a <code>URI</code> object pointing to the physical document.</li>
	<li>Provide a <code>CharSequence</code> object that contains the document itself. 
	(<code>String</code> is a type of <code>CharSequence</code>).</li>
</ul>
<p>The examples below call <code>open()</code> using different methods:</p>
<pre>// Open the input from an InputStream
// filter.open(new FileInputStream(&quot;myFile.properties&quot;))

// Open the input from a URI obtained from a path
// filter.open(new File(&quot;myFile.properties&quot;).toURI());

// Open the input from a URI
// filter.open(new URI(&quot;file:///C:/myFile.properties&quot;));</pre>
<p>Note that while the filters should do their best to implement all the 
different types of <code>open()</code>, this may not be possible in some cases 
because of the format the filter deal with. For example, a&nbsp; filter for 
Adobe Photoshop PSD files would not be able to implement the <code>open()</code> 
method with a string as PSD are binary formats.</p>
<p>In this example we are going to use the third method and provide the content 
of our document as a string:</p>
<pre>// Open the input from a CharSequence
filter.open(&quot;key1=Text1\nkey2=Text2&quot;);</pre>
<p>This is equivalent to opening a physical properties file on the disk that has the 
following content:</p>
<pre>key1=Text1
key2=Text2</pre>
<h3><a name="processInputDoc"></a>Processing the Input Document</h3>
<p>Everything is now in place to start processing the input document.</p>
<p>We use the method <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#hasNext()">IFilter.hasNext()</a></code> to see if there is any event to access. If there is, 
we use 
the method <code><a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()">IFilter.next()</a></code> to get the actual event.</p>
<ul>
	<li>You must always call <code>
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#hasNext()">IFilter.hasNext()</code></a> 
	before calling
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()"><code>IFilter.next()</code></a>.</li>
	<li>You must call
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()"><code>IFilter.next()</code></a> 
	once and only once before the next call to
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#hasNext()">
	<code>IFilter.hasNext()</code></a>.</li>
	<li>Do not rely on <code>
	<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#next()">IFilter.next()</code></a> 
	returning <code>null</code> if there are no more events.</li>
</ul>
<pre>// Proper call of hasNext() and next()
while ( filter.hasNext() ) {
   Event event = filter.next();
   // Do something...
}</pre>
<p>Once you have an event, you query its type using <code>
<a href="../javadoc/net/sf/okapi/common/Event.html#getEventType()">Event.getEventType()</a></code>. The value retuned is one of the constants 
defined in <code>
<a href="../javadoc/net/sf/okapi/common/EventType.html">EventType</a></code>. Then, depending on the type, you can get 
the resource associated with this event (<code><a href="../javadoc/net/sf/okapi/common/Event.html#getResource()">Event.getResource()</a></code>) and access the data in the resource.</p>
<p>After the last event for the input document (<code>END_DOCUMENT</code>) has been read, <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#hasNext()">IFilter.hasNext()</a></code> 
returns false, and you can close the input. Note that it is a good practice for 
the filters to close the input themselves before sending the last event, but you 
should close in case this is not done.</p>
<pre>// Get the events from the input document
while ( filter.hasNext() ) {
   Event event = filter.next();
   // do something with the event...
   // Here, if the event is TEXT_UNIT, we display the key and the extracted text
   if ( event.getEventType() == EventType.TEXT_UNIT ) {
      TextUnit tu = (TextUnit)event.getResource();
      System.out.println(&quot;--&quot;);
      System.out.println(&quot;key=[&quot;+tu.getName()+&quot;]&quot;);
      System.out.println(&quot;text=[&quot;+tu.getSource()+&quot;]&quot;);
   }
}
// Close the input document
filter.close();</pre>
<p>This should generate the following output:</p>
<pre>--
key=[key1]
text=[Text1]
--
key=[key2]
text=[Text2]</pre>
<h2><a name="modifyingDocument"></a>Modifying a Document</h2>
<p>Extracting the text parts of a document is useful, but a more useful feature 
the Okapi Framework offers is writing out the extracted data back into their 
original format.</p>
<p>As we have seen above, when you open a document with a filter, you can 
specified to generate or not the skeleton. The role of the skeleton is to 
store information about the parts of the input document that are not extractable, and to provide 
ways to merge back the parts that are extractable.</p>
<p>Because file formats are very different, they may need to use different type 
of skeleton mechanisms. For example, the skeleton for a binary file such as an OpenOffice.org ODT file (which is really a ZIP file) cannot be treated the same 
way as the skeleton of a Java properties file. The framework offers a 
transparent way to work with the different skeletons and let the user ignore the 
underlying mechanism.</p>
<p>The skeleton parts are passed along with the resources of the 
events. A resource may or may not have an associated skeleton object.</p>
<p>To re-construct the original file format you need both the 
extracted resources and the skeleton parts passed through the events. The framework 
provides the <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">IFilterWriter</a></code> 
interface to do all this transparently.</p>
<h3><a name="creatingFilterAndWriter"></a>Creating the Filter and the Writer</h3>
<p>First you must prepare the filter, just like before, except that we will use 
the HTML filter this time:</p>
<pre>// Create a filter object
IFilter filter = new HtmlFilter();
// Set the filter general options
filter.setOptions(&quot;en&quot;, &quot;UTF-16&quot;, true);</pre>
<p>Then, you need to create an <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">IFilterWriter</a></code> 
object. You do this by calling a method of the filter itself (<code><a href="../javadoc/net/sf/okapi/common/filters/IFilter.html#createFilterWriter()">IFilter.createFilterWriter()</a></code>) 
that provides you with the proper implementation of <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">IFilterWriter</a></code> 
for the given format it supports.</p>
<pre>// Create the writer
IFilterWriter writer = filter.createFilterWriter();</pre>
<h3><a name="configuringWriter"></a>Configuring the Writer</h3>
<p>Once the writer object created you need to set its options. This is done with 
the <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html#setOptions(java.lang.String, java.lang.String)">IFilterWriter.setOptions()</a></code> method.</p>
<p>We need to set the output language, here French (but it could be also the 
same language as the input if needed). And we need to indicate in what encoding the 
output should be written, in our example we will choose Latin-1.</p>
<pre>// Set the writer's options
writer.setOptions(&quot;fr&quot;, &quot;iso-8859-1&quot;);</pre>
<p>We also need to set where the output will be generated. The type of object 
used for output can be different from the one used for the input. For example, 
here we will use a string as the input document, and write the output to a 
physical file.</p>
<p>There are different methods to set the output:</p>
<ul>
	<li>Providing an <code>OutputStream</code> object.</li>
	<li>Providing a <code>URI</code> object pointing to a physical location.</li>
</ul>
<p>We are using the second method in this example:</p>
<pre>// Set the output
writer.setOutput(&quot;myFile_fr.html&quot;);</pre>
<p>Note that the output document is not created when you set the output, but 
only when the filter will start sending events.</p>
<p class="question"><b>Question:</b> Can the output document be the same as the input one?</p>
<p class="answer">Yes, you should be able to overwrite the input document. 
However, to ensure it will 
work, you should <b>always close the input document before closing the output 
document</b>.</p>
<h3>Opening the Input Document</h3>
<p>The next step is to open the input document with the filter. This time we 
will use an HTML string:</p>
<pre>// Open the input from a CharSequence
filter.open(&quot;&lt;html&gt;&lt;head&gt;\n&quot;
   + &quot;&lt;meta http-equiv='Content-Language' content='en'&gt;&lt;/head&gt;\n&quot;
   + &quot;&lt;body&gt;\n&quot;
   + &quot;&lt;p&gt;Text in &lt;b&gt;bold&lt;/b&gt;.&lt;/p&gt;&quot;
   + &quot;&lt;/body&gt;&lt;/html&gt;&quot;);</pre>
<h3><a name="processDocWithoutDhanges"></a>Processing the Document Without Making Changes</h3>
<p>Now that all is set, we can process the document.</p>
<p>Re-writing the input document is achieved simply: You call the <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html#handleEvent(net.sf.okapi.common.Event)">IFilterWriter.handleEvent()</a></code> method each time you get an event from 
the filter, and then close both input and output when all events have been 
processed. (Remember that you should always close the input document before the 
output document, in case you are writing on the same file).</p>
<pre>// Processing the input document
while ( filter.hasNext() ) {
   writer.handleEvent(filter.next());
}
// Closing the filter and the writer
filter.close();
writer.close();</pre>
<p>The code above should create a new file called <code>myFile.fr.properties</code> 
in your current directory and its content should be like this:</p>
<pre>&lt;html&gt;&lt;head&gt;
&lt;meta http-equiv='Content-Language' content='fr'&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Text in &lt;b&gt;bold&lt;/b&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre>
<p>As you can notice, the writer make some modifications automatically: the HTML 
language declaration has been updated to reflect the target language you 
specified: &quot;<code>fr</code>&quot;. The remaining of the content is the same as the 
input.</p>
<h3><a name="processDocWithChanges"></a>Processing the Document and Making Changes</h3>
<p>Obviously the real interest of the writer is to save changes made to the 
extracted text into its original format.</p>
<p>To perform changes in the extracted text you need to handle the <code>
TEXT_UNIT</code> event, which comes with a <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html">TextUnit</a></code> 
resource where the source text is stored.</p>
<p>It is always good practice to isolate the place where you code our changes, so 
we will create a method for it. Our <code>changeTU()</code> method takes one 
parameter: The <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html">TextUnit</a></code> 
resource provided by the <code>TEXT_UNIT</code> event. The modifications are 
done directly in that object.</p>
<p>Before we do any change, we need to check if this text unit is actually 
translatable. While most of the extracted text is translatable, there are cases 
where, for different reasons, the provider of the events (here a filter) 
decided to protect the content of the text unit. A good example of this is the 
XLIFF filter: It returns one text unit for each <code>&lt;trans-unit&gt;</code> of the 
XLIFF document, but some of those <code>&lt;trans-unit&gt;</code> may have their 
<code>translate</code> 
attribute set to <code>no</code>. The <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#isTranslatable()">
TextUnit.isTranslatable()</a></code> method allows you to verify if a given text 
unit is translatable or not, as shown below:</p>
<pre>void changeTU (TextUnit tu) {
   // Check if this unit can be modified
   if ( !tu.isTranslatable() ) return; // If not, return without changes</pre>
<p>Once we have established that we can modify the text, we need to create a copy 
of the source content for the target.</p>
<p>One thing important to keep in mind when working with filters is that some 
input documents can be multilingual (for example a PO file, or an XLIFF 
document). Because of that you may actually already have a target text in your text unit.</p>
<p>The method <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#hasTarget(java.lang.String)">
TextUnit.hasTarget()</a></code> can check if a target for a given language 
exists already. But there is a more convenient way to create the target 
conditionally. The&nbsp; <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#createTarget(java.lang.String, boolean, int)">
TextUnit.createTarget()</a></code> is design for this. It takes several 
parameters:</p>
<ul>
	<li>The language of the target entry to create (here &quot;<code>fr</code>&quot;).</li>
	<li>
	<p>A flag indicating if you want to overwrite the content of a possible 
	existing target for that language. Set it to <code>true</code> to create a 
	new entry even if one exists already. Set it to <code>false</code> to use the 
	existing entry or to create a new entry if none exists.</li>
	<li>A flag indicating what to copy from the source. Use <code>
	IResource.COPY_ALL</code> to copy everything.</li>
</ul>
<pre>   TextContainer tc = tu.createTarget(&quot;fr&quot;, false, IResource.COPY_ALL);</pre>
<p>The result is a <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextContainer.html">
TextContainer</a></code> object, that hold all the target-related data: text, as 
well a properties, annotations, etc.</p>
<p>To make any modification to the content you need to work with a string of 
<a href="glossary.html#codedText">coded text</a>. It is a string with some special characters that markup 
<a href="glossary.html#inlineCode">inline 
codes</a>. Coded text string can usually be manipulated like a normal string, with 
some exceptions.</p>
<p>For this example, we want to convert the text to upper cases, and we can work 
without problem directly with the coded text. To get the coded text use the
<code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#getCodedText()">
TextContainer.getCodedText()</a></code> method. When the conversion is done you 
have to set the modified string back into the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextContainer.html">
TextContainer</a></code> using the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#setCodedText(java.lang.String)">
TextContainer.setCodedText()</a></code> method.</p>
<pre>   String text = tc.getCodedText();
   text = text.toUpperCase();
   tc.setCodedText(text);

   // Or more simply:
   // tc.setCodedText(tc.getCodedText().toUpperCase());
}</pre>
<p>With our <code>changeTU()</code> method done, we can now add it to the main 
loop of the filter's event.</p>
<pre>while ( filter.hasNext() ) {
   Event event = filter.next();
   if ( event.getEventType() == EventType.TEXT_UNIT ) {
      changeTU((TextUnit)event.getResource());
   }
   writer.handleEvent(event);
}
filter.close();
writer.close();</pre>
<p>&nbsp;The output of our new program should look like this:</p>
<pre>&lt;html&gt;&lt;head&gt;
&lt;meta http-equiv='Content-Language' content='fr'&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;TEXT IN &lt;b&gt;BOLD&lt;/b&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre>
<h2><a name="textUnits"></a>Working with Text Units</h2>
<p>One of the most important events generated by the filters is the <code>
TEXT_UNIT</code> event. It corresponds to a logical unit of extractable text of 
the input document. For example, the content of a <code>&lt;p&gt;</code> element in 
HTML, or the value of a key/value pair in a Java properties file. A text unit 
corresponds more or less to a <code>&lt;trans-unit&gt;</code> element in XLIFF.</p>
<p>The text unit holds source and target data for the given extracted text, as 
well as properties (for the whole unit, for the source, as well as for each 
target), and annotations (also for the whole unit, for the source, as well as 
for each target). It is also hold its corresponding skeleton object (if there is 
one).</p>
<p>The bottom line is that you can access the source text from the text unit, as 
well create new translation entries or access existing one (if the input 
document is multilingual).</p>
<p>Each language has a corresponding
<a href="../javadoc/net/sf/okapi/common/resource/TextContainer.html">
<code>
TextContainer</code></a> object that hold the text as well as its associated 
properties and annotations. the text itself is in a
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> object. Those parts are easily accessible from the 
text unit:</p>
<pre>TextUnit tu = new TextUnit(&quot;id1&quot;);
tu.setSourceContent(new TextFragment(&quot;My text&quot;));

TextContainer tc = tu.getSource();
TextFragment tf1 = tc.getContent();
// Or
TextFragment tf2 = tu.getSourceContent();</pre>
<p>In the example above both <code>tf1</code> and <code>tf2</code> point to the 
same object: The source text content of the text unit.</p>
<p>Once you have a
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> you can manipulate it almost like a classic string:</p>
<pre>tf1.append(' ');
tf1.append(&quot;is this.&quot;);
// Prints &quot;My text is this&quot;
System.out.println(tf1.toString());

tf1.insert(3, new TextFragment(&quot;first &quot;));
// Prints &quot;My first text is this.&quot;
System.out.println(tf1.toString());

tf1.remove(13, 21);
// Prints &quot;My first text.&quot;
System.out.println(tf1.toString());</pre>
<p dir="ltr">There is, however, one major difference between a <code>
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html">TextFragment</code></a> 
and a string: the inline codes.</p>
<h3><a name="inlineCodes"></a>Inline Codes</h3>
<p>Inline codes are spans of the extracted content that are not real text, but 
codes/markup embedded in the text. They often represent formatting information. For example, in the HTML content &quot;<code>Text in &lt;b&gt;bold&lt;/b&gt;.</code>&quot; 
the two tags &quot;<code>&lt;b&gt;</code>&quot; and &quot;<code>&lt;/b&gt;</code>&quot; are inline codes.</p>
<p>A
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"> <code>
	TextFragment</code></a> 
object can contain many inline codes:</p>
<pre>TextUnit tu = new TextUnit(&quot;id1&quot;);
TextFragment tf = tu.setSourceContent(new TextFragment(&quot;Text in &quot;));
tf.append(TagType.OPENING, &quot;bold&quot;, &quot;&lt;b&gt;&quot;);
tf.append(&quot;bold&quot;);
tf.append(TagType.CLOSING, &quot;bold&quot;, &quot;&lt;/b&gt;&quot;);
tf.append(&quot;.&quot;);
// Prints &quot;Text in &lt;b&gt;bold&lt;/b&gt;.&quot;
System.out.println(tf.toString());</pre>
<p>Separating text from code allows translation tools to work in a more abstract 
way. For example an RTF text &quot;<code>Text in {\b bold}.</code>&quot; and an HTML text 
&quot;<code>Text in &lt;b&gt;bold&lt;/b&gt;.</code>&quot; can be represented the same way in a
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a>. This allows better handling of the content: Improve translation memory leveraging; 
comparing codes between 
source and target; working with the text (e.g. spell-checking) without having 
the code be in the way; and much more.</p>
<p>The content is separated into two parts: a coded text string where you 
have the real text and special markers for each code; and the list of the codes 
themselves. You can access the coded text with the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#getCodedText(int, int)">
TextFragment.getCodedText()</a></code> method, and the list of codes with the
<code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#getCodes()">
TextFragment.getCodes()</a></code> method. Most of the time simple utilities 
need only to access the coded text.</p>
<pre>String text = tf.getCodedText();
List&lt;Code&gt; codes = tf.getCodes();</pre>
<p>The coded text part contains placeholders to represent the inline codes. each 
one is composed of two special Unicode characters: the first one represent the 
kind of inline code (U+E101: opening, U+E102: closing, U+E103: standalone) and 
the second one is the index of the code in the list of codes. Both special 
characters are in the Private Use Area of Unicode.</p>
<p>There is also a U+E104 special character used for segment placeholder when 
the text is segmented.</p>
<pre>Normal text: Text in <span style="background-color: #FFFF00">&lt;b&gt;</span>bold<span style="background-color: #00FF00">&lt;/b&gt;</span>.
 Coded text: Text in <span style="background-color: #FFFF00">\uE101\uE110</span>bold<span style="background-color: #00FF00">\uE102\uE111</span>.</pre>
<p>The following method takes a
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> and counts the number of character in the real 
text part of the coded text. You can use the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#isMarker(char)">
TextFragment.isMarker()</a></code> helper method to check if a given character 
is an inline code marker or not. If it is one, you need to skip the next 
character as it represents the index of the inline code to the list of codes.</p>
<pre>private static int countChars (TextFragment tf) {
   String text = tf.getCodedText();
   int count = 0;
   for ( int i=0; i&lt;text.length(); i++ ) {
      if ( TextFragment.isMarker(text.charAt(i)) ) i++;
      else count++;
   }
   return count;
}</pre>
<p>If you apply the method above to our
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> and compare it to the other length counts you get:</p>
<ul>
	<li><code>tf.getString().length()</code> = 19</li>
	<li><code>tf.getCodedText().length()</code> = 17</li>
	<li><code>countChars(tf)</code> = 13</li>
</ul>
<h3><a name="modifyingText"></a>Modifying Text</h3>
<p>If you modify a coded text string, you need to set the modified string back 
into the
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> object. This is done with one of the <code>
TextFragment.setCodedText()</code> methods.</p>
<p>The first method set the coded text, and re-use the codes that are 
currently in the
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a>. This implies that the inline code markers in the 
coded text you have modified must be unchanged. Extra or missing codes will 
trigger an error.</p>
<pre>// Prints &quot;Text in &lt;b&gt;bold&lt;/b&gt;.&quot;
System.out.println(tf.toString());

String text = tf.getCodedText();
text = text.toUpperCase();
tf.setCodedText(text);

// Prints &quot;TEXT IN &lt;b&gt;BOLD&lt;/b&gt;.&quot;
System.out.println(tf.toString());</pre>
<p>The second method is to set the new coded text and indicate that missing 
inline code markers in your new text means the corresponding codes in the
	<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html"><code>
	TextFragment</code></a> should be deleted. Only extra codes will trigger an 
error.</p>
<pre>// Prints &quot;TEXT IN &lt;b&gt;BOLD&lt;/b&gt;.&quot;
System.out.println(tf.toString());

text = tf.getCodedText();
text = text.substring(0, 14);
// Allows the deletion of &quot;&lt;/b&gt;&quot;
tf.setCodedText(text, true);

// Prints &quot;TEXT IN &lt;b&gt;BOLD&quot;
System.out.println(tf.toString());</pre>
<p class="question"><b>Question</b>: When the &quot;<code>&lt;b&gt;</code>&quot; code was 
originally added to the text it was set with a <code>TagType.OPENING</code> 
flag. Now that it does not have a corresponding closing tag, don't we have to 
change its type to something else?</p>
<p class="answer">No. The <code>TagType</code> flag remains the same 
(&quot;<code>&lt;b&gt;</code>&quot; is still a start tag). But the marker in the coded text for 
this inline code should now be <code>MARKER_ISOLATED</code> instead of <code>
MARKER_OPENING</code>. This change was done automatically you we called <code>
setCodedText()</code>. We will see more information about how tag types and 
markers relate to each other later.</p>
<p>The third method is to specify the list of codes along with the modified 
coded text. This allows you complete control over the inline codes. If the list 
of codes you provide does not match the inline codes in the coded text string it 
will trigger an error.</p>
<pre>// Prints &quot;TEXT IN &lt;b&gt;BOLD&quot;
System.out.println(tf.toString());

text = tf.getCodedText();
// Create a new set of codes
List&lt;Code&gt; codes = new ArrayList&lt;Code&gt;();
codes.add(new Code(TagType.OPENING, &quot;italic&quot;, &quot;&lt;i&gt;&quot;));
codes.add(new Code(TagType.CLOSING, &quot;italic&quot;, &quot;&lt;/i&gt;&quot;));
// Replace the text &quot;BOLD&quot; by &quot;ITALIC&quot;
text = text.replace(&quot;BOLD&quot;, &quot;ITALIC&quot;);
// Add the marker for the new second inline code
text += (char)TextFragment.MARKER_CLOSING;
text += TextFragment.toChar(1);
tf.setCodedText(text, codes);

// Prints &quot;TEXT IN &lt;b&gt;ITALIC&lt;/b&gt;.&quot;
System.out.println(tf.toString());</pre>
<p>In the code above, note the use of the <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#toChar(int)">
TextFragment.toChar()</a></code> helper method to add the index of the new 
inline code just after the marker. It allows you to convert a code index into 
its special character representation. The reverse method <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextFragment.html#toIndex(char)">
TextFragment.toIndex()</a></code> converts a given character into a code index 
value.</p>
<p>Lastly, you can specify the list of codes along with the modified 
coded text, as well as a flag indicating if missing codes can be removed from 
the provided list of codes. For example, the code below removes all the codes 
and replaces the text with a new one.</p>
<pre>// Prints &quot;TEXT IN &lt;b&gt;ITALIC&lt;/b&gt;.&quot;
System.out.println(tf.toString());

// Remove all inline codes
tf.setCodedText(&quot;Normal text.&quot;, null, true);

// Prints &quot;Normal text.&quot;
System.out.println(tf.toString());</pre>
<h3><a name="tagTypeAndMarkers"></a>TagType and Marker</h3>
<p>Each inline code is associated with a <code>TagType</code> information. It 
can be <code>OPENING</code>, <code>CLOSING</code>, or <code>PLACEHOLDER</code>. 
(It can also be <code>SEGMENTHOLDER</code> in some cases of segmented entries, 
but we will ignore this for now).</p>
<p>You specify this information when adding the code to the fragment:</p>
<pre>tf.append(TagType.OPENING, &quot;bold&quot;, &quot;&lt;b&gt;&quot;);
tf.append(TagType.CLOSING, &quot;bold&quot;, &quot;&lt;/b&gt;&quot;);
tf.append(TagType.PLACEHOLDER, &quot;lb&quot;, &quot;&lt;br/&gt;&quot;);</pre>
<p>You can retrieve it later:</p>
<pre>assert(tf.getCode(0).getTagType() == TagType.OPENING);
assert(tf.getCode(1).getTagType() == TagType.CLOSING);
assert(tf.getCode(2).getTagType() == TagType.PLACEHOLDER);</pre>
<p>This information normally remain unchanged: The code &quot;<code>&lt;b&gt;</code>&quot; is 
always a start tag regardless of where it is and whether it has a corresponding 
closing tag or not.</p>
<p>There is a difference however between what the tag is and how it should be 
represented and manipulated from the viewpoint of an extracted segment. That 
information is related to the position of the inline code in the text and is 
denoted through the kind of markers used to hold the spot of the code in the 
coded text. There are several markers: <code>MARKER_OPENING</code>, <code>
MARKER_CLOSING</code> and <code>MARKER_ISOLATED</code>. (There is also a <code>
MARKER_SEGMENT</code> used in segmented entries, but we will ignore this for 
now).</p>
<p>When a code with <code>TagType.OPENING</code> or <code>TagType.CLOSING</code> 
are alone in a fragment, or otherwise separated from their corresponding closing 
or opening counterpart, the marker is not set to <code>MARKER_OPENING</code> or
<code>MARKER_CLOSING</code>, but to <code>MARKER_ISOLATED</code>.</p>
<pre>Normal: &quot;First <span style="background-color: #FFFF00">&lt;b&gt;</span>bold. Second one<span style="background-color: #00FF00">&lt;/b&gt;</span>.&quot;
 Coded: &quot;First <span style="background-color: #FFFF00"><b>\uE101</b>\uE110</span>bold. Second one<span style="background-color: #00FF00"><b>\uE102</b>\uE111</span>.&quot;
 Codes:  <span style="background-color: #FFFF00">0</span>={&quot;&lt;b&gt;&quot;=TagType.OPENING},
         <span style="background-color: #00FF00">1</span>={&quot;&lt;/b&gt;&quot;=TagType.OPENING}</pre>
<div dir="ltr">
<pre>Normal f1: &quot;First <span style="background-color: #FFFF00">&lt;b&gt;</span>bold. &quot;
 Coded f1: &quot;First <span style="background-color: #FFFF00"><b>\uE103</b>\uE110</span>&quot; (\uE101 becomes \uE103)
 Codes f1: <span style="background-color: #FFFF00">0</span>={&quot;&lt;b&gt;&quot;=TagType.OPENING}

Normal f2: &quot;Second one<span style="background-color: #00FF00">&lt;/b&gt;</span>.&quot;
 Coded f2: &quot;Second one<span style="background-color: #00FF00"><b>\uE103</b>\uE110</span>.&quot; (\uE102 becomes \uE103)
 Codes f2: <span style="background-color: #00FF00">0</span>={&quot;&lt;/b&gt;&quot;=TagType.CLOSING}</pre>
</div>
<p>&nbsp;</p>

</body>

</html>