<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Okapi Framework Developer's Guide - Pipelines</title>
<link rel="stylesheet" type="text/css" href="../okapi.css">
</head>

<body>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
	<tr class="head">
		<td class="head"><h1 class="head">Okapi Framework - Developer's Guide</h1>
		<h2 class="head2">Pipelines</h2></td>
	</tr>
</table>

<ul>
	<li><a href="#overview">Overview</a></li>
	<li><a href="#simplePipeline">Simple Pipeline</a></li>
	<li><a href="#creatingSteps">Creating Steps</a></li>
</ul>
<h2><a name="overview"></a>Overview</h2>
<p>Pipelines are a powerful mechanism to apply a sequences of actions to an 
input document. They allow you to construct processes customized to specific 
projects very easily.</p>
<p>Extract the text &gt;&gt; Apply some change to the text &gt;&gt; Merge back the text into 
its original format.</p>
<p>With the framework this type of sequence is implemented as follow:</p>
<p><code><a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code> 
&gt;&gt; <code><a href="../javadoc/net/sf/okapi/common/pipeline/IPipelineStep.html">
IPipelineStep</a></code> &gt;&gt; <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">
IFilterWriter</a></code></p>
<p>The pipelines allow you to extend this model to include as many steps as you 
need.</p>
<h2><a name="simplePipeline"></a>Simple Pipeline</h2>
<p>A pipeline is represented by a <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/IPipeline.html">IPipeline</a></code> 
interface, and the framework offers a simple implementation for it: The <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/Pipeline.html">Pipeline</a></code> 
class.</p>
<pre>// Create the pipeline
IPipeline pipeline = new Pipeline();</pre>
<p>The framework provides you with pre-defined classes for using any <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code> 
and any <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">
IFilterWriter</a></code>: The <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/FilterPipelineStepAdaptor.html">
FilterPipelineStepAdaptor</a></code> and the <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/FilterWriterPipelineStepAdaptor.html">
FilterWriterPipelineStepAdaptor</a></code> classes.</p>
<p>Creating the initial step for the filter is easy:</p>
<pre>// Create the filter we will use
IFilter filter = new HtmlFilter();
// Create the filter step
IPipelineStep filterStep = new FilterPipelineStepAdaptor(filter);
// Add this step to the pipeline
pipeline.addStep(filterStep);</pre>
<p>Creating the last step for the filter writer is also quite easy:</p>
<pre>// Create the writer we will use
IFilterWriter writer = filter.createFilterWriter();
// Create the writer step (using the writer provider by our filter)
IPipelineStep writerStep = new FilterWriterPipelineStepAdaptor(writer);
// Add this step to the pipeline
pipeline.addStep(writerStep);</pre>
<p>Now we have a two-steps pipeline that can read and re-write a given HTML 
document. To use it, you have to set the input and output options just like when 
you are not using any pipeline:</p>
<pre>// Sets the filter options
filter.setOptions(&quot;en&quot;, &quot;UTF-16&quot;, true);

// Sets the writer options and output
writer.setOptions(&quot;fr&quot;, &quot;UTF-8&quot;);
writer.setOutput(&quot;myPipelineOutput.html&quot;);

String input = &quot;&lt;html&gt;&lt;head&gt;\n&quot;
+ &quot;&lt;meta http-equiv='Content-Language' content='en'&gt;&lt;/head&gt;\n&quot;
+ &quot;&lt;body&gt;\n&quot;
+ &quot;&lt;p&gt;Text in &lt;b&gt;bold&lt;/b&gt;.&lt;/p&gt;&quot;
+ &quot;&lt;/body&gt;&lt;/html&gt;&quot;;</pre>
<p>Once all is set you can one of the <code>process()</code> methods provided by 
the pipeline. That method initiates the first call to the filter and triggers 
the flow of events to go through all the steps. Once the pipeline is not needed 
anymore, you should call <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/IPipeline.html#destroy()">
IPipeline.destroy()</a></code> to clean up any resource used by the steps:</p>
<pre>// Launch the execution
pipeline.process(input);

// Clean up all the pipeline resources
pipeline.destroy();</pre>
<h2><a name="creatingSteps"></a>Creating Steps</h2>
<p>Now we need to add at least one step between the filter and the filter writer 
to have a useful pipeline. This requires to create a new class that implements 
the <code>IPipelineStep</code> interface. The framework makes things easy by 
offering a base class that you can derive from own classes from: <code>
BasePipelineStep</code>.</p>
<p>The only classes you have to implement are <code>getName()</code> to provide 
a name to the step, and whatever handler method for the events you want to act 
upon. Most of the time it will be just <code>handleTextUnit()</code>.</p>
<p>For example, the class below implements <code>handleTextUnit()</code> to 
intercept any <code>TEXT_UNIT</code> event that pass through the pipeline. Here 
we simple do a simple pseudo-translation by replacing all ASCII characters by 
the same one with accents, so the text <code>&quot;A goose quill is more dangerous 
than a lion's claw&quot;</code> becomes <code>&quot;A gõõsè qüìll ìs mõrè ðåñgèrõüs thåñ å 
lìõñ's çlåw&quot;</code>.</p>
<p>In order to create a new target entry, the class needs to know what the 
target language is, so we can pass that information through the class' 
constructor. Otherwise changing the text is fairly simple. See the section
<a href="gettingstarted.html#TextUnits">Working with Text Units</a> for more 
details on how to modify text units.</p>
<pre>public class PseudoTranslateStep extends BasePipelineStep {

   private static final String OLDCHARS = &quot;aeiouycdn&quot;;
   private static final String NEWCHARS = &quot;\u00e5\u00e8\u00ec\u00f5\u00fc\u00ff\u00e7\u00f0\u00f1&quot;;
   private String trgLang;

   public PseudoTranslateStep (String trgLang) {
      this.trgLang = trgLang;
   }

   public String getName () {
      return &quot;PseudoTranslateStep&quot;;
   }

   protected void handleTextUnit (Event event) {
      TextUnit tu = (TextUnit)event.getResource();
      if ( tu.isTranslatable() ) {
         TextFragment tf = tu.createTarget(trgLang, false, IResource.COPY_CONTENT);
         StringBuilder text = new StringBuilder(tf.getCodedText());
         int n;
         for ( int i=0; i&lt;text.length(); i++ ) {
            if ( TextFragment.isMarker(text.charAt(i)) ) i++; // Skip the pair
            else {
               if ( (n = OLDCHARS.indexOf(text.charAt(i))) &gt; -1 ) {
                  text.setCharAt(i, NEWCHARS.charAt(n));
               }
            }
         }
         tf.setCodedText(text.toString());
      }
   }
}</pre>
<p>Once we have defined an implementation for the step that will modify the 
extracted text, we simply need to add it between the input and output steps:</p>
<pre>// Create the step
PseudoTranslateStep pseudoTransStep = new PseudoTranslateStep(&quot;fr&quot;);
pipeline.addStep(pseudoTransStep);</pre>
<p>It may seems more complicated to create a new class for each new step instead 
of directly working in a single class, But the benefits are important: 
Each step defined as a separate class can be re-used easily in different processes.</p>
<p>You should see each step as a component independent of everything else. It 
should not be filter-specific and not use any global parameter. It should also 
be aware of inline codes, as well as the translate and the preserve-whitespaces 
information attached to each text unit. The <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html">TextUnit</a></code> 
class may provide plenty of information you can query: <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getType()">
TextUnit.getType()</a></code>, <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getName()">
TextUnit.getName()</a></code>, <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getMimeType()">
TextUnit.getMimeType()</a></code>, <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getAnnotation(java.lang.Class)">
TextUnit.getAnnotation()</a></code>, <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getProperty(java.lang.String)">
TextUnit.getProperty()</a></code>, etc. Make use of them to drive the different 
actions performed on the extracted text.</p>
<p>&nbsp;</p>

</body>

</html>
