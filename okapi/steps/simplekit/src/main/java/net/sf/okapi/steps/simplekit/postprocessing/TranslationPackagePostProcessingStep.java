/*===========================================================================
  Copyright (C) 2010 by the Okapi Framework contributors
-----------------------------------------------------------------------------
  This library is free software; you can redistribute it and/or modify it 
  under the terms of the GNU Lesser General Public License as published by 
  the Free Software Foundation; either version 2.1 of the License, or (at 
  your option) any later version.

  This library is distributed in the hope that it will be useful, but 
  WITHOUT ANY WARRANTY; without even the implied warranty of 
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser 
  General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License 
  along with this library; if not, write to the Free Software Foundation, 
  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

  See also the full LGPL text here: http://www.gnu.org/copyleft/lesser.html
===========================================================================*/

package net.sf.okapi.steps.simplekit.postprocessing;

import java.io.File;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;

import net.sf.okapi.common.Event;
import net.sf.okapi.common.EventType;
import net.sf.okapi.common.IParameters;
import net.sf.okapi.common.Util;
import net.sf.okapi.common.filters.IFilter;
import net.sf.okapi.common.filters.IFilterConfigurationMapper;
import net.sf.okapi.common.filterwriter.IFilterWriter;
import net.sf.okapi.common.pipeline.BasePipelineStep;
import net.sf.okapi.common.pipeline.annotations.StepParameterMapping;
import net.sf.okapi.common.pipeline.annotations.StepParameterType;
import net.sf.okapi.common.resource.RawDocument;
import net.sf.okapi.common.resource.TextUnit;
import net.sf.okapi.steps.simplekit.common.IPackageReader;
import net.sf.okapi.steps.simplekit.common.Manifest;
import net.sf.okapi.steps.simplekit.common.ManifestItem;
import net.sf.okapi.steps.simplekit.common.MergingInfoFile;

public class TranslationPackagePostProcessingStep extends BasePipelineStep {

	private final Logger logger = Logger.getLogger(getClass().getName());

	private boolean isDone;
	private Manifest manifest;
	private Iterator<ManifestItem> manifestItemIter;
	
	// Variables needed for filter-based merging
	private IPackageReader reader;
	private IFilterConfigurationMapper fcMapper;
	private IFilter filter;
	private IFilterWriter writer;
	
	public String getDescription () {
		return "Post-Processes the translated files of a package generated by the Translation Package Creation step."
			+ " Expects: raw document. Sends back: filter events.";
	}

	@Override
	public void destroy () {
		super.destroy();
		// make sure we close and free the merging objects
		endMerging();
	}

	public String getName () {
		return "Translation Package Post-Processing (EXPERIMENTAL)";
	}

	@StepParameterMapping(parameterType = StepParameterType.FILTER_CONFIGURATION_MAPPER)
	public void setFilterConfigurationMapper (IFilterConfigurationMapper fcMapper) {
		this.fcMapper = fcMapper;
	}
	
	@Override
	public boolean isDone() {
		return isDone;
	}

	@Override
	public Event handleEvent (Event event) {
		switch ( event.getEventType() ) {
		case START_BATCH:
			isDone = true;
			break;
		case START_BATCH_ITEM:
			// Needed because the process() method of the pipeline expects
			// hasEvents to be set to true to prime things.
			isDone = false;
			return event;
		case RAW_DOCUMENT:
			// Return the first event from the manifest
			return primeManifest(event);
		}
		// Other cases
		if ( !isDone ) { // If we are currently post-processing
			// Get the next event from the post-processing
			return getNextEvent();
		}
		// Else: we are not processing, just pass the events through
		return event;
	}
	
	private Event primeManifest (Event event) {
		// The raw document is the manifest
		RawDocument rd = event.getRawDocument();
		if ( rd.getInputURI() == null ) {
			throw new UnsupportedOperationException("Post-processing requires an input URI.");
		}
		
		isDone = false;
		File manifestFile = new File(rd.getInputURI());
		
		// Load the manifest file to use
		manifest = new Manifest();
		manifest.load(manifestFile);
		// Check the package where the manifest has been found
		// This auto-disabled the merging of the files not found
		manifest.checkPackageContent();
		//TODO: warning if number of errors returned > 0
		
		// Open the post-processing dialog if possible
		//TODO ??? or do it somehow through the step parameters?

		// Create the iterator for the manifest items.
		manifestItemIter = manifest.getItems().values().iterator();
		// Get the first event of the first item
		return getFirstEventOfNextItem();
	}

	private Event startRTFConversion (ManifestItem item) {
		//TODO
		return Event.NOOP_EVENT;
	}
	
	private void endMerging () {
		if ( reader != null ) {
			//reader.close();
			reader = null;
		}
		if ( writer != null ) {
			writer.close();
			writer = null;
		}
		if ( filter != null ) {
			filter.close();
			filter = null;
		}
	}
	
	private Event startSkeletonPostProcessing (ManifestItem item) {
		Event event = Event.NOOP_EVENT;
		try {
			endMerging(); // Make sure previous objects are closed
			// File to merge
			String fileToMerge = manifest.getFileToMergePath(item.getDocId());
			logger.info("\nMerging: " + fileToMerge);

			// Get the skeleton path
			String skeletonPath = manifest.getRoot() + File.separator + manifest.getSkeletonLocation()
				+ File.separator + String.format("%d.skl", item.getDocId());
			
			// Get the merging info file path and load it
			String mrgInfoPath = manifest.getRoot() + File.separator + manifest.getSkeletonLocation()
				+ File.separator + String.format("%d.fprm", item.getDocId());
			MergingInfoFile mif = new MergingInfoFile();
			mif.read(mrgInfoPath);

			// Instantiate the relevant filter
			filter = fcMapper.createFilter(mif.getFilterId(), filter);
			// Instantiate the filter configuration object and set it
			IParameters params = filter.getParameters();
			// Load them only if the filter has parameters
			if ( params != null ) {
				params.fromString(mif.getFilterParameters());
			}

			// Instantiate a package reader of the proper type
			if ( reader == null ) {
				reader = (IPackageReader)Class.forName(mif.getReaderClass()).newInstance();
			}

//			reader.openDocument(fileToMerge, manifest.getSourceLanguage(), manifest.getTargetLanguage());
			
			// Initializes the input
			File f = new File(skeletonPath);
			filter.open(new RawDocument(f.toURI(), mif.getInputEncoding(),
				manifest.getSourceLanguage(), manifest.getTargetLanguage()));
			
			// Initializes the output
			String outputPath = manifest.getFileToGeneratePath(item.getDocId());
			Util.createDirectories(outputPath);
			writer = filter.createFilterWriter();
			writer.setOptions(manifest.getTargetLanguage(), mif.getOutputEncoding());
			writer.setOutput(outputPath);
			
			// Process the document
			return getNextEvent();
		}
		catch ( Exception e ) {
			// Log and move on to the next file
			Throwable e2 = e.getCause();
			logger.log(Level.SEVERE, "Merging error. " + ((e2!=null) ? e2.getMessage() : e.getMessage()), e);
		}
		return event;
	}

	/**
	 * Gets the next post-processing event.
	 * If there is no more event in the current item, this returns the first event of
	 * the next item, or (if there is no more) it stops the post-processing and 
	 * return a noop event.
	 * @return the next post-processing event.
	 */
	private Event getNextEvent () {
		// Get the next event
		while ( filter.hasNext() ) {
			Event event = filter.next();
			if ( event.getEventType() == EventType.TEXT_UNIT ) {
				processTextUnit(event.getTextUnit());
			}
			return event;
		}
		
		// No more event for this item: Try to move to the next input document to post-process
		return getFirstEventOfNextItem();
	}

	/**
	 * Gets the first post-processing event of the next item to post-process.
	 * If there are no more item, the post-processing is stopped and a noop event is returned.  
	 * @return the next post-processing event.
	 */
	private Event getFirstEventOfNextItem () {
		// Look for the next item available
		ManifestItem item = null;
		while ( manifestItemIter.hasNext() ) {
			// Detect the type of post-processing to do
			item = manifestItemIter.next();
			if ( !item.selected() ) {
				item = null;
				continue;
			}
			// Else: this one is ok
			break;
		}
		
		// If no more items or empty manifest: nothing else to process
		if ( item == null ) {
			isDone = true; // We are done
			return Event.NOOP_EVENT;
		}
		
		// Else: select the type of post-processing to do and start the process
		if ( item.getPostProcessingType().equals(ManifestItem.POSPROCESSING_TYPE_RTF) ) {
			return startRTFConversion(item);
		}
		else { // Default: use the reader-driven process
			return startSkeletonPostProcessing(item);
		}
	}

	private void processTextUnit (TextUnit tu) {
		//TODO
	}

}
